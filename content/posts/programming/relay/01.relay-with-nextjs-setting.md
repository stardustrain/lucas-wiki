---
title: 'Relay with Next.js : setting'
description: Next.js에 Relay를 이용하기 위한 준비를 하고, 간단한 GitHub API를 이용해보는 예제.
keywords: [Relay, Next.js, Next.js with Relay, Relay using Next.js]
url: https://wiki.lucashan.space/programming/relay/01.relay-with-nextjs-setting/
date: 2021-06-02
tags: [Programming, '2021', 'relay']
---

작년 [GraphQL 서버를 도입](/programming/introduce-a-graphql-to-odc/)하면서 web application에서 사용할 client를 고민했었다. [Apollo Client](https://www.apollographql.com/docs/react/)와 [Relay](https://relay.dev/)가 그 고민의 대상들이었는데, 최종적으로 Apollo Client를 선택했다.

생각보다 Relay 자체를 학습하고 이해하는데 생각보다 많은 시간이 걸릴것 같다는 생각이 들었고, GraphQL조차 생소하게 받아들였던 팀원들이 이를 부담스러워 한 탓도 있었다. 결정적으로는 Relay의 사용 당위성과 정해진 시간안에 끝낼 수 있겠다는 확신이 없었기 때문에 [**그 분2**](https://blog.roto.codes/)를 설득하지 못한 본인의 탓이 컸다.

Apollo Client를 이용해 무사히 web application에 GraphQL 적용을 마쳤고, 이 경험을 토대로 새로운 프로젝트에도 잘 사용할 수 있었다. 하지만 사용하면서 뭔가 한마디의 말로 설명하기 힘든 아쉬움이 있었다. GraphQL을 사용하고 있지만 GraphQL답게 사용하지 못하고 있는 듯한 묘한 감정이었는데, [Thinking in Relay](https://relay.dev/docs/principles-and-architecture/thinking-in-relay/)라는 글을 읽어보고 `Next.js`와 함께 사용해 보기로 하였다.

Relay라는 framework가 생소하기도 했고, 생소한 만큼 Next.js와 함께 사용할 수 있게 초기 설정을 하는데 시간이 조금 걸렸다. 생각보다 예제가 많지도 않았고, 참고할만한 자료들도 조금 부족한 느낌이었다(검색을 잘 못한거라면 할말은 없지만). 뒤돌아 생각해보면 크게 어려운 개념들이 있지는 않았으나, 처음 프로젝트를 설정할때의 난감함을 잊지않기위해 글을 남기려고 한다. 혹시나 Relay와 Next.js를 함께 도입하려는 분들이 있으시면 이 글이 약간이나마 도움이 되었으면 좋겠다.

이 글에서는 [GitHub API v4](https://docs.github.com/en/graphql)를 이용해 간단한 화면을 만들어 보고자 한다.

\* [Thinking in Relay](https://relay.dev/docs/principles-and-architecture/thinking-in-relay/)의 도입부에서 data fetching에 대한 Relay에 접근방식이 Facebook이 React를 통해 얻은 경험에서 영감을 받았음을 밝히고있다. 그들이 어떤 고민을 하였고, 어떤 노력을 하였는지 GraphQL, Relay 등에 관심이 없더라도 한번쯤 읽어보면 좋을것 같다.

## 1. Relay?

Facebook에서 만든, data 기반의 React application을 구축하기 위한 JavaScript framework이다. [Relay의 GitHub repository](https://github.com/facebook/relay)에 소개된 Relay의 특징은 다음과 같다.

[[tip]]
| - **Declarative**: Never again communicate with your data store using an imperative API. Simply declare your data requirements using GraphQL and let Relay figure out how and when to fetch your data.
| - **Colocation**: Queries live next to the views that rely on them, so you can easily reason about your app. Relay aggregates queries into efficient network requests to fetch only what you need.
| - **Mutations**: Relay lets you mutate data on the client and server using GraphQL mutations, and offers automatic data consistency, optimistic updates, and error handling.

먼저, 필요한 데이터를 요청하는 것을 _명령하지 말고 **`선언`**하라_ 고 쓰여있다. 말 그대로 "어떻게" 데이터를 가져올 것인지 표현하지 말고, "어떠한" 데이터가 필요한지만 명시하라는 뜻이다.

또한, 선언된 query가 관계있는 view와 가까이 위치하기 때문에 각 component의 기능을 쉽게 추론할 수 있는 장점이 생긴다. 딱 여기까지만 생각했을때는 Apollo client와 별 차이가 없는 듯 보이지만, [Relay compiler](https://relay.dev/docs/guides/compiler/)의 존재를 알게되면 확연한 차이가 발생한다는 사실을 쉽게 알 수 있다. Relay compiler를 통해, Relay는 선언되어있는 query를 효율적으로 모아서 필요한 데이터만 가져오는 역할을 수행한다.

## 2. Next.js application 생성

우선 Next.js [공식문서](https://nextjs.org/docs/api-reference/create-next-app)에 있는 `create-next-app`을 이용해 Next.js application을 설정한다. Next.js application이 잘 설치되었다면, TypeScript설정을 해준다. Next.js에 TypeScript를 설정하는 방법역시 [문서](https://nextjs.org/docs/basic-features/typescript)에 잘 나와있다.

```bash
$ yarn create next-app relay-next-test
$ cd relay-next-test
$ yarn add -D typescript @types/react @types/node
$ touch tsconfig.json
$ yarn dev
```

## 3. Relay 설정

### 1. Relay 의존성 설치

먼저 Relay를 활용하는데 필요한 패키지들을 모두 설치해준다.

```bash
$ yarn add react-relay relay-runtime
$ yarn add -D relay-compiler relay-config babel-plugin-relay graphql @types/react-relay @types/relay-runtime
```

각 패키지의 역할은 다음과 같다. 좀 더 자세한 설명은 [Relay:Architecture Overview](https://relay.dev/docs/principles-and-architecture/architecture-overview/)에 나와있다.

- react-relay
  - Relay와 React를 연결해주는 integration layer 모듈
- relay-runtime
  - Relay core 모듈
- relay-compiler
  - 사전 컴파일을 위한 모듈
- babel-plugin-relay
  - GraphQL을 런타임 아티팩트로 만들어 주기 위한 babel plugin
- relay-config
  - babel-plugin-relay 및 relay-compiler에서 설정파일을 사용할 수 있게 도와주는 모듈
- graphql

### 2. Relay config

그 다음은 Relay에 대한 configuration을 진행한다. 위의 단계에서 `relay-config`를 설치했기 때문에 project root에 `relay.config.js` 파일을 만들어 주면 된다.

```bash
$ touch relay.config.js
```

그리고 기본적으로 아래와 같은 옵션을 설정해준다. 더 많은 옵션은 [여기](https://github.com/facebook/relay/blob/master/packages/relay-compiler/bin/RelayCompilerMain.js#L48)에서 확인 가능하다.

```js
// relay.config.js
module.exports = {
  src: '.', // 컴파일 대상인 파일들의 경로
  schema: './schema.graphql',
  exclude: ['**/node_modules/**', '**/__mocks__/**', '**/__generated__/**', '**/.next/**'], // 컴파일시 제외해야 할 파일들의 경로
  artifactDirectory: '__generated__', // 컴파일된 아티팩트들을 모아주는 경로
}
```

`src`에는 컴파일 대상인 파일들의 경로를 설정해준다. Next.js의 기본적인 directory 구성은 project root에 기본적인 구성이 묶여있기 때문에 현재 경로로 설정했다.

`schema`는 컴파일에 필요한 GraphQL API서버의 schema 파일이다. 보통 GraphQL 서버에 Introspection query를 요청하고, 그 결과로 만들어지기 떄문에 직접 작성할 일은 없다고 보면 좋을 것 같다. 아직 schema 파일을 만들지는 않았지만 다음 단계에서 만들어 줄 것이기 때문에 미리 설정해 주었다.

`exclude`는 컴파일시 제외해야 할 파일들의 경로, `artifactDirectory`는 컴파일된 아티팩트들을 모아주는 경로에 대한 설정이다.

그 다음, GraphQL과 관련한 요소들을 런타임 아티팩트로 만들어 주기 위해 babel plugin을 설정해준다. Next.js의 babel설정을 override하기 위해 우선 `.babelrc`를 만들어 준 후 다음과 같이 간단하게 설정하면 된다.

```bash
$ touch .babelrc
```

```json
// .babelrc
{
  "presets": ["next/babel"],
  "plugins": ["relay"]
}
```

### 3. Generate schema file

이제 `relay.config.js`에 설정한대로, 사용할 GraphQL API를 설명하는 `schema.graphql` 파일을 자동으로 만들수있게 해야한다. 일단 nodejs환경에서 GraphQL server에 요청을 보내야하기 때문에 [isomorphic-fetch](https://github.com/matthew-andrews/isomorphic-fetch) 패키지를 설치한다.

```bash
$ yarn add isomorphic-fetch
$ yarn add -D @types/isomorphic-fetch
```

위에 쓰여있듯, [GitHub API v4](https://docs.github.com/en/graphql)를 이용할 것이기 때문에 일단 GitHub personal access token을 발급받아야한다. 발급받는 방법은 [이 문서](https://docs.github.com/en/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token)를 참고하면 된다.

토큰을 정상적으로 발급받았다면 원하는 경로에 아래의 코드를 작성한다. 이 예시에서는 `./scripts/generateSchema.js`에 작성한다고 가정한다.

```js
// ./scripts/generateSchema.js
const fs = require('fs')
const path = require('path')
const fetch = require('isomorphic-fetch')
const { getIntrospectionQuery, buildClientSchema, printSchema } = require('graphql')

const generateSchema = async () => {
  try {
    const response = await fetch('https://api.github.com/graphql', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `bearer ${GITHUB_TOKEN}`,
      },
      body: JSON.stringify({
        query: getIntrospectionQuery(), // #1
      }),
    })

    const res = await response.json()
    const sdl = printSchema(buildClientSchema(res.data)) // #2
    const parentPath = path.join(__dirname, '../')
    fs.writeFileSync(`${parentPath}/schema.graphql`, sdl) // #3
  } catch (e) {
    console.error(e)
  }
}

generateSchema()
```

GitHub API에 [Introspection query](https://graphql.org/learn/introspection/)를 보내 지원하는 쿼리에 대한 모든 정보를 요청한다(#1). 그 다음 `buildClientSchema()`함수를 이용해 서버에서 응답한 스키마 정보를 통해 GraphqlSchema instance를 만들고, `printSchema()`함수를 이용해 SDL로 바꿔준다(#2). 그리고 `relay.config.js`의 `schema` property에 설정한 경로에 파일이 생성되도록 한다(#3).

### 4. Add npm scripts

이제 Relay를 사용하기 위한 기반설정이 어느정도 끝났기 때문에, `package.json`의 `scripts`를 아래와 같이 설정한다.

```json
// package.json
{
  "scripts": {
    "generate:schema": "node ./scripts/generateSchema.js",
    "relay": "relay-compiler",
    "dev": "yarn run relay && next dev",
    "build": "yarn run relay && next build",
    "start": "next start"
  }
}
```

그리고, 정해진 경로에 `schema.graphql`파일이 잘 생성되는지 확인해본다.

```bash
$ yarn run generate:schema
yarn run v1.22.10
$ node ./scripts/generateSchema.js
✨  Done in 6.52s.
```

Project root에 `schema.graphql` 파일이 생성되었고, 내부를 확인해 보면 다음과 같은 schema에 대한 정의들이 만들어져 있을것이다. 여기까지 확인했다면 거의 다 설정한것과 마찬가지이다.

<details>
  <summary>schema.graphql</summary>

```graphql
"""
Autogenerated input type of AcceptEnterpriseAdministratorInvitation
"""
input AcceptEnterpriseAdministratorInvitationInput {
  """
  The id of the invitation being accepted
  """
  invitationId: ID!

  """
  A unique identifier for the client performing the mutation.
  """
  clientMutationId: String
}

# ...
```

</details>

## 4. Next.js에서 Relay 사용하기

### 1. Set RelayEnvironment - fetch helper

```ts
import fetch from 'isomorphic-fetch'
import type { Variables } from 'relay-runtime'

const fetchGraphQL = async (query: string, variables: Variables) => {
  console.log(`fetch query ${params.name} with ${JSON.stringify(variables)}`)
  const response = await fetch('https://api.github.com/graphql', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `bearer ${GITHUB_TOKEN}`,
    },
    body: JSON.stringify({
      query,
      variables,
    }),
  })

  return await response.json()
}

export default fetchGraphQL
```

### 2. Set RelayEnvironment - Environment

```ts
import { useMemo } from 'react'
import { Environment, Network, RecordSource, Store } from 'relay-runtime'
import type { FetchFunction } from 'relay-runtime'

import fetchGraphQL from './fetchGraphQL'

let relayEnvironment: Environment

const fetchRelay: FetchFunction = async (params, variables) => {
  return fetchGraphQL(params.text, variables)
}

const createEnvironment = () => {
  return new Environment({
    network: Network.create(fetchRelay),
    store: new Store(new RecordSource()),
  })
}

type InitialRecords = ConstructorParameters<typeof RecordSource>[number]
export const initEnvironment = (initialRecords?: InitialRecords) => {
  const environment = relayEnvironment ?? createEnvironment()

  if (initialRecords) {
    environment.getStore().publish(new RecordSource(initialRecords))
  }

  if (typeof window === 'undefined') return environment

  if (!relayEnvironment) {
    relayEnvironment = environment
  }

  return relayEnvironment
}

export const useEnvironment = (initialRecords: InitialRecords) => {
  const store = useMemo(() => initEnvironment(initialRecords), [initialRecords])
  return store
}
```

### 3. Add RelayEnvironment to \_app.tsx

```tsx
import '../styles/globals.css'
import { RelayEnvironmentProvider } from 'react-relay/hooks'
import { useEnvironment } from '../relay/RelayEnvironment'

function App({ Component, pageProps }) {
  const environment = useEnvironment(pageProps.initialRecords)
  return (
    <RelayEnvironmentProvider environment={environment}>
      <Component {...pageProps} />
    </RelayEnvironmentProvider>
  )
}

export default App
```

### 4. GitHub API 붙여보기

#### 1. index.tsx 작성

```tsx
import { fetchQuery, graphql } from 'react-relay'
import { initEnvironment } from '../relay/RelayEnvironment'

export default function Home() {
  return <div></div>
}

const query = graphql`
  query pages_index_MarketplaceListings_Query($first: Int) {
    marketplaceListings(first: $first) {
      edges {
        node {
          id
          app {
            name
          }
          fullDescription
        }
      }
    }
  }
`

export const getStaticProps = async () => {
  const environment = initEnvironment()
  try {
    const queryProps = await fetchQuery<any>(environment, query, {
      first: 20,
    }).toPromise()
    const initialRecords = environment.getStore().getSource().toJSON()

    return {
      props: {
        ...queryProps,
        initialRecords,
      },
    }
  } catch (e) {
    console.error(e)
    throw e
  }
}
```

#### 2. TypeScript로 Relay compile하기

```bash
$ yarn add -D relay-compiler-language-typescript
```

```js
module.exports = {
  src: '.', // project root
  schema: './schema.graphql',
  exclude: ['**/node_modules/**', '**/__mocks__/**', '**/__generated__/**', '**/.next/**'],
  artifactDirectory: '__generated__',
  language: 'typescript',
}
```

```bash
$ yarn run relay
```

<details>
  <summary>generated 확인</summary>

```ts
/* tslint:disable */
/* eslint-disable */
// @ts-nocheck

import { ConcreteRequest } from 'relay-runtime'
export type pages_index_MarketplaceListings_QueryVariables = {
  first?: number | null
}
export type pages_index_MarketplaceListings_QueryResponse = {
  readonly marketplaceListings: {
    readonly edges: ReadonlyArray<{
      readonly node: {
        readonly app: {
          readonly name: string
        } | null
        readonly fullDescription: string
      } | null
    } | null> | null
  }
}
export type pages_index_MarketplaceListings_Query = {
  readonly response: pages_index_MarketplaceListings_QueryResponse
  readonly variables: pages_index_MarketplaceListings_QueryVariables
}

/*
query pages_index_MarketplaceListings_Query(
  $first: Int
) {
  marketplaceListings(first: $first) {
    edges {
      node {
        app {
          name
          id
        }
        fullDescription
        id
      }
    }
  }
}
*/

const node: ConcreteRequest = (function () {
  var v0 = [
      {
        defaultValue: null,
        kind: 'LocalArgument',
        name: 'first',
      },
    ],
    v1 = [
      {
        kind: 'Variable',
        name: 'first',
        variableName: 'first',
      },
    ],
    v2 = {
      alias: null,
      args: null,
      kind: 'ScalarField',
      name: 'name',
      storageKey: null,
    },
    v3 = {
      alias: null,
      args: null,
      kind: 'ScalarField',
      name: 'fullDescription',
      storageKey: null,
    },
    v4 = {
      alias: null,
      args: null,
      kind: 'ScalarField',
      name: 'id',
      storageKey: null,
    }
  return {
    fragment: {
      argumentDefinitions: v0 /*: any*/,
      kind: 'Fragment',
      metadata: null,
      name: 'pages_index_MarketplaceListings_Query',
      selections: [
        {
          alias: null,
          args: v1 /*: any*/,
          concreteType: 'MarketplaceListingConnection',
          kind: 'LinkedField',
          name: 'marketplaceListings',
          plural: false,
          selections: [
            {
              alias: null,
              args: null,
              concreteType: 'MarketplaceListingEdge',
              kind: 'LinkedField',
              name: 'edges',
              plural: true,
              selections: [
                {
                  alias: null,
                  args: null,
                  concreteType: 'MarketplaceListing',
                  kind: 'LinkedField',
                  name: 'node',
                  plural: false,
                  selections: [
                    {
                      alias: null,
                      args: null,
                      concreteType: 'App',
                      kind: 'LinkedField',
                      name: 'app',
                      plural: false,
                      selections: [v2 /*: any*/],
                      storageKey: null,
                    },
                    v3 /*: any*/,
                  ],
                  storageKey: null,
                },
              ],
              storageKey: null,
            },
          ],
          storageKey: null,
        },
      ],
      type: 'Query',
      abstractKey: null,
    },
    kind: 'Request',
    operation: {
      argumentDefinitions: v0 /*: any*/,
      kind: 'Operation',
      name: 'pages_index_MarketplaceListings_Query',
      selections: [
        {
          alias: null,
          args: v1 /*: any*/,
          concreteType: 'MarketplaceListingConnection',
          kind: 'LinkedField',
          name: 'marketplaceListings',
          plural: false,
          selections: [
            {
              alias: null,
              args: null,
              concreteType: 'MarketplaceListingEdge',
              kind: 'LinkedField',
              name: 'edges',
              plural: true,
              selections: [
                {
                  alias: null,
                  args: null,
                  concreteType: 'MarketplaceListing',
                  kind: 'LinkedField',
                  name: 'node',
                  plural: false,
                  selections: [
                    {
                      alias: null,
                      args: null,
                      concreteType: 'App',
                      kind: 'LinkedField',
                      name: 'app',
                      plural: false,
                      selections: [v2 /*: any*/, v4 /*: any*/],
                      storageKey: null,
                    },
                    v3 /*: any*/,
                    v4 /*: any*/,
                  ],
                  storageKey: null,
                },
              ],
              storageKey: null,
            },
          ],
          storageKey: null,
        },
      ],
    },
    params: {
      cacheID: 'fbc2c680e8078ef83e32b6227543aba2',
      id: null,
      metadata: {},
      name: 'pages_index_MarketplaceListings_Query',
      operationKind: 'query',
      text:
        'query pages_index_MarketplaceListings_Query(\n  $first: Int\n) {\n  marketplaceListings(first: $first) {\n    edges {\n      node {\n        app {\n          name\n          id\n        }\n        fullDescription\n        id\n      }\n    }\n  }\n}\n',
    },
  }
})()
;(node as any).hash = 'db038a4ad6787233e5d1b2a65efccf55'
export default node
```

</details>

#### 3. index.tsx에 type 선언하기

```ts
import type { pages_index_MarketplaceListings_Query } from '../__generated__/pages_index_MarketplaceListings_Query.graphql'

const queryProps = await fetchQuery<pages_index_MarketplaceListings_Query>(
  environment,
  query,
  {}
).toPromise()
```

```tsx
import type { InferGetStaticPropsType } from 'next'

export default function Home({ marketplaceListings }: InferGetStaticPropsType<typeof getStaticProps>) {
  return (
    // ...
  )
}
```

```tsx
import { fetchQuery, graphql } from 'react-relay'
import { initEnvironment } from '../relay/RelayEnvironment'

import type { InferGetStaticPropsType } from 'next'
import type { pages_index_MarketplaceListings_Query } from '../__generated__/pages_index_MarketplaceListings_Query.graphql'

export default function Home({
  marketplaceListings,
}: InferGetStaticPropsType<typeof getStaticProps>) {
  return (
    <div>
      <ul>
        {marketplaceListings.edges.map(({ node }) => (
          <li key={node.id}>
            <div>App name: {node.app?.name}</div>
            <div>Description: {node.fullDescription}</div>
          </li>
        ))}
      </ul>
    </div>
  )
}

const query = graphql`
  query pages_index_MarketplaceListings_Query($first: Int) {
    marketplaceListings(first: $first) {
      edges {
        node {
          id
          app {
            name
          }
          fullDescription
        }
      }
    }
  }
`

export const getStaticProps = async () => {
  const environment = initEnvironment()
  try {
    const queryProps = await fetchQuery<pages_index_MarketplaceListings_Query>(environment, query, {
      first: 20,
    }).toPromise()
    const initialRecords = environment.getStore().getSource().toJSON()

    return {
      props: {
        ...queryProps,
        initialRecords,
      },
    }
  } catch (e) {
    console.error(e)
    throw e
  }
}
```

15. yarn dev

```bash
$ yarn dev
```

---

#### 참고

- [Next.js with relay modern example](https://github.com/vercel/next.js/tree/canary/examples/with-relay-modern)
- [Next.js data fetching](https://nextjs.org/docs/basic-features/data-fetching)
- [Next.js typescript](https://nextjs.org/docs/basic-features/typescript)
- [Next.js Customizing Babel Config](https://nextjs.org/docs/advanced-features/customizing-babel-config)
- [Relay Installation and Setup](https://relay.dev/docs/getting-started/installation-and-setup/)
- [Relay Step-by-step Guide](https://relay.dev/docs/getting-started/step-by-step-guide/)
- [Three ways to represent your GraphQL schema](https://www.apollographql.com/blog/backend/schema-design/three-ways-to-represent-your-graphql-schema/)
