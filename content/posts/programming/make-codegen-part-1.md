---
title: Code generator 개발기 (Part 1)
description: Code generator를
keywords: []
url: https://wiki.lucashan.space/programming/make-codegen-part-1/
date: 2023-06-09
tags: [Programming, '2023']
image: https://pbs.twimg.com/profile_images/540333799557439489/-s9uoLIN_400x400.png
---

[융디 피드백]

- gRPC등 기술을 고려하고 실패하는 과정에서 BE 개발자와 소통한 부분을 추가

## 1. RESTful API를 마주하다.

프런트엔드 개발을 하다 보면 수많은 고민을 마주하게 되지만, 그 중에서도 API를 요청하는 부분을 관리하는 것은 언제나 많은 고민이 수반된다. 일단 어떤 라이브러리를 사용할 것인가 부터, 코드를 어디에 어떻게 위치시켜야 API의 변화에 쉽고 유연하게 대응할 수 있을지 같은 정답이 없는 선택이 필요하다. 덧붙여, 시간이 지날수록 늘어나는 API endpoint의 관리도 걱정거리 중 하나로 다가온다.

### 코드 베이스에서의 고민

특히 이제는 업계 표준이라고 말할 수 있는 TypeScript를 사용하게 되면 한가지 고민을 추가적으로 해야하는데, 바로 API의 반환 타입을 어떻게 관리할 것인가에 관한 고민이다. TypeScript의 특성 상 API의 반환값을 지정하지 않고 사용할 수 없기 때문에 반드시 선언해줘야 한다. 이를 위해 프런트엔드 개발자는 보통 두 가지 방법 중 하나를 선택하게 되는데, 하나는 모든 요청에 대한 반환 타입을 any로 선언하는 것이고 다른 하나는 문서에 기술된 반환값을 보고 타입을 수동으로 관리하는 것이다.

경험상 타입을 any로 관리하지 않고 직접 수동으로 관리하게 되면 문제가 연이어 발생했었다.

- 프로젝트 초기에는 타입을 꾸준히 업데이트, 관리
- 프로젝트가 막바지에 이를 수록 여러가지 이유(바쁘거나, 급한 버그 수정 등)로 타입을 적당히 *컴파일이 실패하지 않는 선*에서 관리
- 제품 배포 후 유지보수가 진행될 수록 새로운 타입이 양산되거나 index signature, union, intersection 등이 남발되며 runtime 안정성은 점점 떨어짐
- 결국 타입 선언이 하나의 레거시가 되어 아무도 신경을 쓰지 않게 됨

물론 모든 프로젝트에서 발생하는 일은 아니지만 대체적으로 위와 같이 흘러 갔을 경우, API와 클라이언트 간 인터페이스 역할을 맡고있는 타입의 의미가 유명무실해진다. 이 뜻은 곧 API와 클라이언트간 역할, 책임, 협력을 신뢰할 수 없게된다는 의미로 귀결된다. 제품을 위해 가장 긴밀하게 협력해야하는 두 객체가 서로를 신뢰하지 못하게 되는 것이다.

### 프런트엔드 개발자들의 불필요한 논의

수동관리를 해야한다는 것은 사람 혹은 협력하는 팀 단위 마다 관리하는 방법에 대한 생각과 방법이 상이할 수 있다는 것을 의미한다. 이는 일관성 있는 타입 관리를 위해서 좁게는 협력 단위끼리, 넓게는 프런트엔드 팀 전체의 합의가 필요하다는 결론이 도출된다. 팀 전체의 합의가 이루어졌다고 하더라도 이 합의가 안전한 것은 아니다. 만약 누군가가 새로운 관리 방법을 제안한다면 처음부터 다시 길고 지루한 논의를 해야할까?

사실 이러한 기술적인 논의 자체가 나쁜것은 아니지만, 개인적으로 이런 종류의 논의는 정답이 없고 소모적이라고 생각한다. 이 문제를 해결해 주는 자동화 도구가 있다면 논의 자체가 불필요하기 때문이다.

만약 이런 문제를 도구를 통해 해결할 수 있다면 불필요한 논의를 할 시간을 다른 논의에 사용할 수 있다. 이를테면 제품의 사용성, 코드를 더 잘 작성하는 방법, 배포 시간을 줄이는 방법 등이 *다른 논의*에 해당한다. 이런 논의는 제품 자체의 생산성에 좀 더 유의미한 영향을 줄 수 있다.

### 프런트엔드 개발자와 백엔드 개발자의 진실게임

보통 RESTful API를 제공하는 서버를 구축하게되면 대부분은 문서화 도구로 Swagger를 사용하게 된다. Swagger를 사용하게 되면 재미있게도 높은 확률로 프런트엔드 개발자와 백엔드 개발자간의 A-chicken-and-egg-problem이 발생한다.

이를테면, API 개발자도 사람이다보니, 당연히 구축된 API와 Swagger로 제공되는 문서상의 스펙이 다른 경우가 분명히 발생한다. 또한 프런트엔드 개발자들도 각자 일하는 스타일이 다르기 때문에 Swagger로 제공되는 문서를 보지 않고 개발하는 경우도 생긴다. 이렇게 되면 *어차피 보지도 않는데 문서를 업데이트하면 뭐하나*라는 생각과, *어차피 잘 맞지도 않는데 문서를 왜보나*라는 생각을 서로 하게 된다. 나중에 '어쩌다 이렇게 되었을까?'라는 생각을 하지만 이 문제의 명확한 원인은 끝내 알수 없게 된다.

결국 프런트엔드 개발자는 API의 반환타입을 직접 확인해가며 타입을 작성하게 된다. 제일 확실한 방법일 것 같지만 몇가지 문제가 발생한다.

하나는 프로퍼티의 값이 null 혹은 undefined일 수도 있는 문제이다. 예를들어 다음과 같은 응답이 있을 경우,

```json
{
  "user": {
    "name": "user name"
  }
}
```

만약 user 프로퍼티가 null일수 있다면 아래와 같은 코드에서 문제가 발생할 수 있다.

```javascript
user.name.split(' ') // Uncaught TypeError: Cannot read properties of null (reading 'name')
```

또다른 문제는

이렇게되면 실제 runtime에서 에러가 발생할 때까지 API의 변경을 눈치채지 못하게될 확률이 생긴다. 물론 TypeScript가 runtime 안정성을 완전히 보장하지는 않지만, 최소한의 안전장치가 느슨해지는 것이다.

RESTful API는 분명 좋은 컨셉이라고 생각한다. 다만, 늘 그렇듯 문제는 사람에게 있다. 그렇기 때문에 이 문제에서 *사람의 손길을 최대한 걷어내 보려는 시도*를 하게 되었다.

## 2. 모색했던 해결책

이전에 사용했었던 기술 중에서 현재 팀에 적용 가능할 것으로 예상되는 몇가지 해결책을 모색해 보았지만, 모두 채택하지 못했다.

### GraphQL

개인적으로 [GraphQL](https://graphql.org/)이 이 문제를 해결하는 가장 우아하면서도 확실한 방법이라고 생각했다. 이미 이전 팀에서 GraphQL로 BFF(Backend For Frontend) 서버를 구축하여 운영했던 경험이 있었고 사이드프로젝트에도 적극 사용했기 때문에 생소한 기술도 아니었다. CTO인 향로에게 조심스럽게 도입에 대해 이야기했지만 결국 거절당했다. 정확히는, 내부 서비스에서 사용하는건 문제가 없지만 외부로 공개되는 서비스에 대해서는 도입할 수 없을것 같다는 대답이었다. 이에 대한 몇가지 이유는 아래와 같았다.

- GraphQL을 사용하면 DB model이 너무 드러나게 된다.
- GraphQL은 ORM에 지나치게 의존한다.
- 모니터링을 어느정도 수준까지 할 수 있는지, 현재 우리가 사용하는 모니터링 도구가 GraphQL을 잘 지원하는지 알 수 없다.
- BFF는 서비스 레이어를 늘리기 때문에 팀의 규모를 고려해 보았을 때 관리하기에 부담이 될 수 있다.
- GraphQL을 경험한 사람이 백엔드팀, 프런트엔드팀 각 1명씩 밖에 없다. 다소 학습 곡선이 높아 보이는데, 경험자가 적은 부분이 도입의 장애물로 작용할 여지가 있다.
- 비즈니스 상황이 급박하게 바뀔수도 있는데, 개발팀이 GraphQL로 전환하는 일 때문에 속도를 맞추지 못할 우려가 있다.

기술적인 이유에 대해서는 개인적으로 의아한 부분도 있었지만, 그 외적인 부분에서는 너무나 맞는 이유라고 생각했다. 더군다나 최근 인프랩팀이 발빠르게 움직이고 있는 상황에서 새로운 기술 스택 도입이라는 결정이 걸림돌로 작용할수는 없었다.

### Client side GraphQL

[Client side GraphQL](https://github.com/hasura/client-side-graphql#graphql-without-a-server) 역시 고려대상에 포함되었지만, 결국 스스로 포기하게 되었다. 클라이언트 코드에 포함된 GraphQL schema가 API에 대한 인터페이스 역할을 할 수는 있게지만, resolver에서 API를 호출해야하기 때문에 근본적인 문제를 해결할 방법은 아니라고 판단했다.

### gRPC

GraphQL과 비슷한 관점에서 접근했지만, 이를 이용해 API를 구현해야하는 백엔드 개발자들에게는 GraphQL 보다 더 낯선 방법이었다는 사실을 금새 깨닫게 되었다. 같은 셀의 백엔드 개발자 동료와 논의를 해보았을때 GraphQL 보다 긍정적인 반응을 얻지 못했기 때문이다. 제품의 안정성도 중요하지만, 그렇다고해서 바쁜 백엔드 팀에게 생소한 기술을 권유할 수는 없었다.

## 3. 커뮤니티에서 힌트를 얻다.

GraphQL 커뮤니티 내에는 [The Guild](https://the-guild.dev/)라는 오픈소스 개발자 집단이 있다. The Guild에서 GraphQL과 관련한 강력한 오픈소스를 많이 관리하는데, 그 중 하나가 [Code generator](https://the-guild.dev/graphql/codegen)이다. GraphQL을 활용하며 큰 도움을 받았던 라이브러리인데, OpenAPI Specification을 대상으로 한 비슷한 라이브러리가 있을 것이라는 생각을 하게 되었다. RESTful API가 더 오래 사용된 만큼 비슷한 필요성이 먼저 제기되었을거라 생각했고, [openapi-generator](https://openapi-generator.tech/)라는 라이브러리를 찾을 수 있었다.

설치하고 사용해보기까지 얼마 걸리지 않았는데, openapi-generator를 도입한 모범사례를 소개하는 글이 워낙 많았고 사용하기가 그렇게까지 어렵지 않았기 때문이다. 이런저런 옵션을 살펴볼수록 정말 잘 만든 라이브러리라는 생각을 갖게 되었다.

## 4. 바퀴를 다시 만들 결정을 하다.

개인적으로 바퀴를 다시 만드는 것을 상당히 지양하는 편이다. 이미 잘 만들어진 바퀴를 사용해 더 높은 차원의 일을 할 수 있고, 내가 만든 바퀴가 잘 굴러가리라는 보장이 없기 때문이다. 하지만 이번에는 조금 달랐는데, openapi-generator를 사용하면서 아쉬운 부분들이 등장했기 때문이다.

### 1. 산출물에 대한 아쉬움

- 개인적으로 바퀴를 재발명하는 것은 상당히 지양하는 편
- 하지만, OAS codegen을 사용했을때의 산출물이 썩 마음에 들지 않았음.
  - Verbose한 generation 결과
  - template을 관리해야하는 번거로움
  - 분명히 인프랩만의 요구사항이 등장할 것으로 예상함 -> 3rd party library이기 때문에 대응이 어려움
- 이전의 사용 경험이 좋았기 때문에, GraphQL code generator의 결과물과 동일한 형태가 좋을 것이라 생각.
  - 이에, 한번 만들어 보자는 생각을 하게 되었음.

## 5. 목표

"OAS가 서버-클라이언트의 인터페이스 역할을 해야한다"

- File 혹은 network 요청을 통해 OAS json을 직접 parsing하여 원하는 형태의 file로 만들 수 있어야 한다.
- FE 개발자가 BE API의 schema 변화에 최대한 번잡하지 않게 대응할 수 있어야 한다.
- FE 개발자가 원하는 API를 선택할 수 있어야 한다. -> 필터링 기능
- BE에서 선언한 response를 JSON validator를 통해 검증할 수 있는 typeguard가 자동으로 생성되어야 한다.
- BE 개발자는 FE의 번거로움을 생각하지 않고 API를 생산할 수 있어야 한다.
- BE 개발자가 선언한 Swagger 선언과 실제 API response의 형태가 일치하는지 integration test에서 검증할 수 있어야 한다.
  - Elixir의 doc test 개념 차용
